#!/bin/ksh
    IDENT="@(#)Title:     C++ object renamer"
   AUTHOR="@(#)Author:    Gennady F. Bystritsky (gfb@tonesoft.com)"
  VERSION="@(#)Version:   1.1"
COPYRIGHT="@(#)Copyright: Tone Software Corporation (1997,1998)"
PRODSTAMP="
########################################################################
# C++ object renamer. Copyright(c) 1997,1998 Tone Software Corporation #
########################################################################
"
unset ERRLOG
LANG=C export LANG

RedirectErrors=YES
 ShowProdStamp=NO
       SigList="1 2 3 8 15"

PrintUsage () {
  ShowMsg "USAGE: $ScriptName [-x<debug level>] <from> <to> [<file>...]"
}

CleanUp () {
  eval `EntryPoint 3`
  [ "${ERRLOG:+set}" = set ] && rm -f "$ERRLOG"
}

main () {
  : unset ERRLOG
  [ $# -eq 0 ] || {
    while getopts "x:" opt; do
      case "$opt" in
        x)
          DebugLevel=$OPTARG
        ;;
        *) 
          PrintUsage; return 1
        ;;
      esac
    done
    shift `expr $OPTIND - 1`
  }
  eval `EntryPoint 1`

  [ $# -gt 1 ] || {
    PrintUsage; return 1
  }
  FromPattern1=$1
  ToPattern1=$2
  shift 2
  unset FromPattern2 ToPattern2
  [ $# -eq 0 ] && {
    fromName=${FromPattern1}
    toName=${ToPattern1}
    FromPattern1=`basename "${FromPattern1}"`
    ToPattern1=`basename "${ToPattern1}"`
    FromPattern2=`toupper "${FromPattern1}"`
    ToPattern2=`toupper "${ToPattern1}"`
    unset list
    for f in $fromName*; do
      Modify "$f" && {
        ext=`echo $f|sed -n "s%^$fromName%%p"`
        [ "${ext:+set}" = set ] && {
          ShowMsg "Renaming: $f -> $toName$ext"
          mv -f "$f" "$toName$ext"
        }
      }
    done
    return 0
  }
  for arg
  do
    Modify "$arg"
  done
  return ${?}
}

Modify() {
  eval `EntryPoint 2`
  Patient=$1
  VerifyFile "$Patient" || {
    ErrMsg "Cannot open file \"$Patient\"."
    return 2
  }
  [ -w "${Patient}" ] || {
    ErrMsg "Cannot write to file \"$Patient\"."
    return 2
  }
  status=3
  ed - "$Patient" << EOM && status=0
1,\$s%$FromPattern1%$ToPattern1%g
w
q
EOM
  [ "${FromPattern2:+set}" = set ] && {
  ed - "$Patient" << EOM && status=0
1,\$s%$FromPattern2%$ToPattern2%g
w
q
EOM
  }
  return ${status}
}

##################
# Script Library #
##################

ScriptName=`basename $0`; status=0; umask 0
AWK=nawk; { $AWK ''; } >/dev/null 2>&1 || AWK=awk

> "${ERRLOG:=/tmp/$ScriptName.$$}"
exec 3>&1 4>&2 
[ "$RedirectErrors" = YES ] && exec 2>"$ERRLOG" 1>&2

UPPER="[A-Z]"; LOWER="[a-z]"
tr "[A-Z]" "[a-z]" </dev/null 1>&0 2>&1 || {
  UPPER="[:upper:]"; LOWER="[:lower:]"
}

tolower () {
  echo $*|tr "$UPPER" "$LOWER"
}

toupper () {
  echo $*|tr "$LOWER" "$UPPER"
}

ErrMsg () {
  echo "$ScriptName: $*" 1>&4 2>&1
}

ShowMsg () {
  echo "$*" 1>&3 2>&4
}

GenDirPath () {
  [ $# -eq 1 ] && {
    (cd "$1">/dev/null 2>&1  && pwd)
  }
  return $?
}

ShowProgress () {
  cnt=0; max=${2:-75}
  while read line;do
    [ "$cnt" -eq 0 ] && ShowMsg "${1:-Doing} \c"
    ShowMsg ".\c"; cnt=`expr $cnt + 1`
    [ $cnt -gt "$max" ] && {
      cnt=0; ShowMsg;
    }
  done
  [ $cnt -eq 0 ] || ShowMsg
}

PrintVars () {
  for v in $*
  do
    eval echo $v=\$$v
  done
}

VerifyDir () {
  eval test -d "$1" -a -r "$1"; return $?
}

VerifyFile () {
  eval test -f "$1" -a -r "$1"; return $?
}

VerifyProg () {
  eval test -f "$1" -a -x "$1"; return $?
}

ExtractValues () {
  [ $# -gt 1 ] && {
    file=$1; unset pattern; shift
    for arg
    do
      arg=`echo $arg|sed -n '/^[a-zA-Z][a-zA-Z1-9_]*$/p'`
      [ "${arg:+set}" = set ] && {
        [ "${pattern:+set}" = set ] && {
          pattern="${pattern};"
        }
        search='^[ 	]*'"${arg}"'=\([^`;]*\)[ 	]*$'
        replace="${arg}="\''\1'\'
        pattern="${pattern}s/$search/$replace/gp"
      }
    done
    [ "${pattern:+set}" = set ] && VerifyFile "$file" && {
      eval `sed -n "$pattern"<"$file"`
    }
  }
}

EntryPoint () {
  [ "${DebugLevel:=0}" -ge "${1:-1}" ] && {
    echo 'echo "[Function: $0]" 1>&2; set -xv'
  }
}

AwkLibrary='
  function norm(str){
    while(substr(str,1,1)==" ") str = substr(str,2);
    while(substr(str,length(str),1)==" ")
      str = substr(str,1,length(str)-1)
    return str
  }
'

trap CleanUp 0 $SigList
[ "$ShowProdStamp" = YES ] &&  ShowMsg "$PRODSTAMP"

main "$@"
exit $?

#############
# TEMPLATES #
#############

Fun () {
  eval `EntryPoint 5`
  return 0
}

$AWK '
  '"$AwkLibrary"'
'

#############
#############
